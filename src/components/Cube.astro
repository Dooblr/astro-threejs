---
// Cube.astro - Updated with orbit controls for touch/mouse orbiting
---

<div id="three-container" class="loading">Loading Three.js Cube...</div>

<script>
  import * as THREE from 'three';
  
  let cleanup = null;
  
  function initCube() {
    const container = document.getElementById('three-container');
    if (!container) {
      console.error('Three.js container not found');
      return;
    }
    
    try {
      console.log('Initializing Three.js cube...');
      
      // Remove loading class
      container.classList.remove('loading');
      
      // Scene setup
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0a0a0a);
      
      // Camera setup with better defaults
      const camera = new THREE.PerspectiveCamera(
        75, 
        container.clientWidth / container.clientHeight, 
        0.1, 
        1000
      );
      camera.position.set(0, 0, 5);

      // Renderer setup with improved settings
      const renderer = new THREE.WebGLRenderer({ 
        antialias: true,
        alpha: false,
        powerPreference: "high-performance"
      });
      
      renderer.setSize(container.clientWidth, container.clientHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setClearColor(0x0a0a0a, 1);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      
      // Clear container and add canvas
      container.innerHTML = '';
      container.appendChild(renderer.domElement);

      // Create enhanced cube with better materials
      const geometry = new THREE.BoxGeometry(2, 2, 2);
      
      // Create wireframe material with glow effect
      const wireframeMaterial = new THREE.MeshBasicMaterial({
        color: 0x00d4ff,
        wireframe: true,
        transparent: true,
        opacity: 0.8
      });
      
      // Create solid material for faces
      const solidMaterial = new THREE.MeshPhongMaterial({
        color: 0x1a1a2e,
        transparent: true,
        opacity: 0.1,
        side: THREE.DoubleSide
      });
      
      // Create cube group
      const cubeGroup = new THREE.Group();
      
      // Solid cube
      const solidCube = new THREE.Mesh(geometry, solidMaterial);
      cubeGroup.add(solidCube);
      
      // Wireframe cube
      const wireframeCube = new THREE.Mesh(geometry, wireframeMaterial);
      cubeGroup.add(wireframeCube);
      
      scene.add(cubeGroup);

      // Add lighting for better visual effects
      const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0x00d4ff, 0.8);
      directionalLight.position.set(5, 5, 5);
      directionalLight.castShadow = true;
      scene.add(directionalLight);
      
      const pointLight = new THREE.PointLight(0xff6b6b, 0.5);
      pointLight.position.set(-5, -5, 5);
      scene.add(pointLight);

      // Orbit controls implementation
      class OrbitControls {
        constructor(camera, domElement) {
          this.camera = camera;
          this.domElement = domElement;
          this.target = new THREE.Vector3();
          
          // Rotation state
          this.spherical = new THREE.Spherical();
          this.sphericalDelta = new THREE.Spherical();
          
          // Pan state
          this.panOffset = new THREE.Vector3();
          
          // Zoom state
          this.scale = 1;
          this.zoomSpeed = 1.0;
          
          // Rotation settings
          this.rotateSpeed = 1.0;
          this.enableRotate = true;
          this.enablePan = false;
          this.enableZoom = true;
          this.enableDamping = true;
          this.dampingFactor = 0.05;
          
          // Internal state
          this.isPointerDown = false;
          this.pointerPositions = {};
          
          this.setupEventListeners();
          this.update();
        }
        
        setupEventListeners() {
          // Mouse events
          this.domElement.addEventListener('mousedown', this.onMouseDown.bind(this));
          this.domElement.addEventListener('wheel', this.onMouseWheel.bind(this));
          this.domElement.addEventListener('contextmenu', (e) => e.preventDefault());
          
          // Touch events
          this.domElement.addEventListener('touchstart', this.onTouchStart.bind(this));
          this.domElement.addEventListener('touchmove', this.onTouchMove.bind(this));
          this.domElement.addEventListener('touchend', this.onTouchEnd.bind(this));
          
          // Global events
          document.addEventListener('mousemove', this.onMouseMove.bind(this));
          document.addEventListener('mouseup', this.onMouseUp.bind(this));
        }
        
        getPointerPosition(event) {
          const rect = this.domElement.getBoundingClientRect();
          return {
            x: ((event.clientX - rect.left) / rect.width) * 2 - 1,
            y: -((event.clientY - rect.top) / rect.height) * 2 + 1
          };
        }
        
        onMouseDown(event) {
          event.preventDefault();
          this.isPointerDown = true;
          this.rotateStart = this.getPointerPosition(event);
        }
        
        onMouseMove(event) {
          if (!this.isPointerDown || !this.enableRotate) return;
          
          event.preventDefault();
          
          const position = this.getPointerPosition(event);
          const deltaX = position.x - this.rotateStart.x;
          const deltaY = position.y - this.rotateStart.y;
          
          this.rotateLeft(2 * Math.PI * deltaX * this.rotateSpeed);
          this.rotateUp(2 * Math.PI * deltaY * this.rotateSpeed);
          
          this.rotateStart = position;
        }
        
        onMouseUp() {
          this.isPointerDown = false;
        }
        
        onMouseWheel(event) {
          if (!this.enableZoom) return;
          
          event.preventDefault();
          event.stopPropagation();
          
          if (event.deltaY < 0) {
            this.dollyIn();
          } else if (event.deltaY > 0) {
            this.dollyOut();
          }
        }
        
        onTouchStart(event) {
          event.preventDefault();
          
          const touches = event.touches;
          
          if (touches.length === 1) {
            this.isPointerDown = true;
            this.rotateStart = this.getPointerPosition(touches[0]);
          } else if (touches.length === 2) {
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            this.distanceStart = Math.sqrt(dx * dx + dy * dy);
          }
        }
        
        onTouchMove(event) {
          event.preventDefault();
          
          const touches = event.touches;
          
          if (touches.length === 1 && this.isPointerDown) {
            const position = this.getPointerPosition(touches[0]);
            const deltaX = position.x - this.rotateStart.x;
            const deltaY = position.y - this.rotateStart.y;
            
            this.rotateLeft(2 * Math.PI * deltaX * this.rotateSpeed);
            this.rotateUp(2 * Math.PI * deltaY * this.rotateSpeed);
            
            this.rotateStart = position;
          } else if (touches.length === 2) {
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (this.distanceStart) {
              const factor = this.distanceStart / distance;
              if (factor > 1) {
                this.dollyOut();
              } else if (factor < 1) {
                this.dollyIn();
              }
              this.distanceStart = distance;
            }
          }
        }
        
        onTouchEnd(event) {
          this.isPointerDown = false;
          this.distanceStart = null;
        }
        
        rotateLeft(angle) {
          this.sphericalDelta.theta -= angle;
        }
        
        rotateUp(angle) {
          this.sphericalDelta.phi -= angle;
        }
        
        dollyIn() {
          this.scale /= Math.pow(0.95, this.zoomSpeed);
        }
        
        dollyOut() {
          this.scale *= Math.pow(0.95, this.zoomSpeed);
        }
        
        update() {
          const offset = new THREE.Vector3();
          const quat = new THREE.Quaternion().setFromUnitVectors(
            this.camera.up, 
            new THREE.Vector3(0, 1, 0)
          );
          const quatInverse = quat.clone().invert();
          
          const lastPosition = new THREE.Vector3();
          const lastQuaternion = new THREE.Quaternion();
          
          return () => {
            const position = this.camera.position;
            
            offset.copy(position).sub(this.target);
            offset.applyQuaternion(quat);
            
            this.spherical.setFromVector3(offset);
            
            if (this.enableDamping) {
              this.spherical.theta += this.sphericalDelta.theta * this.dampingFactor;
              this.spherical.phi += this.sphericalDelta.phi * this.dampingFactor;
              
              this.sphericalDelta.theta *= (1 - this.dampingFactor);
              this.sphericalDelta.phi *= (1 - this.dampingFactor);
            } else {
              this.spherical.theta += this.sphericalDelta.theta;
              this.spherical.phi += this.sphericalDelta.phi;
              
              this.sphericalDelta.set(0, 0, 0);
            }
            
            // Apply zoom
            this.spherical.radius *= this.scale;
            this.spherical.radius = Math.max(1, Math.min(100, this.spherical.radius));
            this.scale = 1;
            
            // Restrict phi to prevent flipping
            this.spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, this.spherical.phi));
            
            this.spherical.makeSafe();
            
            offset.setFromSpherical(this.spherical);
            offset.applyQuaternion(quatInverse);
            
            position.copy(this.target).add(offset);
            this.camera.lookAt(this.target);
            
            return lastPosition.distanceToSquared(this.camera.position) > 1e-6 ||
                   8 * (1 - lastQuaternion.dot(this.camera.quaternion)) > 1e-6;
          };
        }
        
        dispose() {
          this.domElement.removeEventListener('mousedown', this.onMouseDown);
          this.domElement.removeEventListener('wheel', this.onMouseWheel);
          this.domElement.removeEventListener('contextmenu', (e) => e.preventDefault());
          this.domElement.removeEventListener('touchstart', this.onTouchStart);
          this.domElement.removeEventListener('touchmove', this.onTouchMove);
          this.domElement.removeEventListener('touchend', this.onTouchEnd);
          document.removeEventListener('mousemove', this.onMouseMove);
          document.removeEventListener('mouseup', this.onMouseUp);
        }
      }

      // Initialize orbit controls
      const controls = new OrbitControls(camera, renderer.domElement);
      const updateControls = controls.update();

      // Animation loop
      function animate() {
        requestAnimationFrame(animate);
        
        const time = Date.now() * 0.001;
        
        // Update controls
        updateControls();
        
        // Add subtle continuous rotation
        cubeGroup.rotation.x += 0.002;
        cubeGroup.rotation.y += 0.003;
        
        // Floating animation
        cubeGroup.position.y = Math.sin(time * 0.5) * 0.1;
        
        // Animate lighting
        pointLight.position.x = Math.sin(time * 2) * 3;
        pointLight.position.z = Math.cos(time * 2) * 3;
        
        // Update wireframe opacity for breathing effect
        wireframeMaterial.opacity = 0.6 + Math.sin(time * 3) * 0.2;
        
        renderer.render(scene, camera);
      }
      animate();

      // Handle window resize
      function handleResize() {
        if (!container.parentElement) return;
        
        const width = container.clientWidth;
        const height = container.clientHeight;
        
        if (width === 0 || height === 0) return;
        
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        
        renderer.setSize(width, height);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      }
      
      window.addEventListener('resize', handleResize);
      
      // Initial resize
      handleResize();
      
      // Cleanup function
      cleanup = () => {
        controls.dispose();
        window.removeEventListener('resize', handleResize);
        
        if (container.contains(renderer.domElement)) {
          container.removeChild(renderer.domElement);
        }
        
        // Dispose of Three.js resources
        renderer.dispose();
        geometry.dispose();
        wireframeMaterial.dispose();
        solidMaterial.dispose();
        
        scene.clear();
      };
      
    } catch (error) {
      console.error('Error initializing Three.js cube:', error);
      container.innerHTML = '<div class="error">Failed to load Three.js cube<br>Please refresh the page</div>';
    }
  }
  
  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initCube);
  } else {
    // DOM is already loaded
    setTimeout(initCube, 100);
  }
  
  // Cleanup on page unload
  window.addEventListener('beforeunload', () => {
    if (cleanup) {
      cleanup();
    }
  });
</script>

<style>
  #three-container {
    width: 100%;
    height: 100%;
    position: relative;
    border-radius: inherit;
    overflow: hidden;
    cursor: grab;
  }
  
  #three-container:active {
    cursor: grabbing;
  }
  
  #three-container canvas {
    display: block;
    width: 100% !important;
    height: 100% !important;
    border-radius: inherit;
    touch-action: none;
  }
  
  #three-container.loading {
    display: flex;
    align-items: center;
    justify-content: center;
    background: var(--glass-bg);
    color: var(--text-secondary);
    font-size: 16px;
    cursor: default;
  }
</style>