---
// Particles.astro
---

<div id="particles-container" style="width: 100%; height: 400px; background: #111;"></div>

<script>
  import * as THREE from 'three';
  
  function initParticles() {
    const container = document.getElementById('particles-container');
    if (!container) {
      console.error('Particles container not found');
      return;
    }
    
    console.log('Initializing particle system...');
    
    // Scene setup
    const scene = new THREE.Scene();
    
    // Camera setup
    const camera = new THREE.PerspectiveCamera(
      75, 
      container.clientWidth / container.clientHeight, 
      0.1, 
      1000
    );
    camera.position.z = 100;

    // Renderer setup
    const renderer = new THREE.WebGLRenderer({ 
      antialias: true,
      alpha: true 
    });
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.setClearColor(0x111111, 1);
    
    // Clear container and add canvas
    container.innerHTML = '';
    container.appendChild(renderer.domElement);

    // Particle system
    const particleCount = 2000;
    const positions = new Float32Array(particleCount * 3);
    const colors = new Float32Array(particleCount * 3);
    const velocities = new Float32Array(particleCount * 3);
    
    // Mouse position
    const mouse = new THREE.Vector2();
    const mouseInfluence = 20;
    
    // Initialize particles
    for (let i = 0; i < particleCount; i++) {
      const i3 = i * 3;
      
      // Random positions
      positions[i3] = (Math.random() - 0.5) * 200;
      positions[i3 + 1] = (Math.random() - 0.5) * 200;
      positions[i3 + 2] = (Math.random() - 0.5) * 200;
      
      // Random velocities
      velocities[i3] = (Math.random() - 0.5) * 0.5;
      velocities[i3 + 1] = (Math.random() - 0.5) * 0.5;
      velocities[i3 + 2] = (Math.random() - 0.5) * 0.5;
      
      // Rainbow colors
      const hue = Math.random();
      const color = new THREE.Color().setHSL(hue, 0.8, 0.6);
      colors[i3] = color.r;
      colors[i3 + 1] = color.g;
      colors[i3 + 2] = color.b;
    }

    // Create geometry and material
    const geometry = new THREE.BufferGeometry();
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    
    const material = new THREE.PointsMaterial({
      size: 2,
      vertexColors: true,
      transparent: true,
      opacity: 0.8,
      blending: THREE.AdditiveBlending
    });
    
    const particles = new THREE.Points(geometry, material);
    scene.add(particles);

    // Mouse move handler
    function onMouseMove(event) {
      const rect = container.getBoundingClientRect();
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
    }
    
    container.addEventListener('mousemove', onMouseMove);

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      
      const positions = particles.geometry.attributes.position.array;
      const colors = particles.geometry.attributes.color.array;
      
      for (let i = 0; i < particleCount; i++) {
        const i3 = i * 3;
        
        // Current particle position
        const x = positions[i3];
        const y = positions[i3 + 1];
        const z = positions[i3 + 2];
        
        // Mouse influence
        const mouseX = mouse.x * 100;
        const mouseY = mouse.y * 100;
        const distanceToMouse = Math.sqrt((x - mouseX) ** 2 + (y - mouseY) ** 2);
        
        if (distanceToMouse < mouseInfluence) {
          const force = (mouseInfluence - distanceToMouse) / mouseInfluence;
          const angle = Math.atan2(y - mouseY, x - mouseX);
          
          velocities[i3] += Math.cos(angle) * force * 0.1;
          velocities[i3 + 1] += Math.sin(angle) * force * 0.1;
          
          // Color shift when near mouse
          const time = Date.now() * 0.005;
          const hue = (time + i * 0.01) % 1;
          const color = new THREE.Color().setHSL(hue, 1, 0.8);
          colors[i3] = color.r;
          colors[i3 + 1] = color.g;
          colors[i3 + 2] = color.b;
        } else {
          // Return to original colors
          const hue = (i / particleCount + Date.now() * 0.0001) % 1;
          const color = new THREE.Color().setHSL(hue, 0.8, 0.6);
          colors[i3] = color.r;
          colors[i3 + 1] = color.g;
          colors[i3 + 2] = color.b;
        }
        
        // Update positions with velocity
        positions[i3] += velocities[i3];
        positions[i3 + 1] += velocities[i3 + 1];
        positions[i3 + 2] += velocities[i3 + 2];
        
        // Apply damping
        velocities[i3] *= 0.98;
        velocities[i3 + 1] *= 0.98;
        velocities[i3 + 2] *= 0.98;
        
        // Boundary wrapping
        if (positions[i3] > 100) positions[i3] = -100;
        if (positions[i3] < -100) positions[i3] = 100;
        if (positions[i3 + 1] > 100) positions[i3 + 1] = -100;
        if (positions[i3 + 1] < -100) positions[i3 + 1] = 100;
        if (positions[i3 + 2] > 100) positions[i3 + 2] = -100;
        if (positions[i3 + 2] < -100) positions[i3 + 2] = 100;
      }
      
      particles.geometry.attributes.position.needsUpdate = true;
      particles.geometry.attributes.color.needsUpdate = true;
      
      // Rotate the entire particle system slowly
      particles.rotation.y += 0.001;
      
      renderer.render(scene, camera);
    }
    animate();

    // Handle window resize
    function handleResize() {
      const width = container.clientWidth;
      const height = container.clientHeight;
      
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      
      renderer.setSize(width, height);
    }
    
    window.addEventListener('resize', handleResize);
    
    // Cleanup function
    return () => {
      container.removeEventListener('mousemove', onMouseMove);
      window.removeEventListener('resize', handleResize);
      if (container.contains(renderer.domElement)) {
        container.removeChild(renderer.domElement);
      }
      renderer.dispose();
      geometry.dispose();
      material.dispose();
    };
  }
  
  // Run when component mounts
  document.addEventListener('DOMContentLoaded', () => {
    // Small delay to ensure the cube component has loaded first
    setTimeout(initParticles, 100);
  });
</script>